<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>VaeDeveloper — Living Graph with Nodes</title>
<style>
  html, body {
    margin: 0;
    background: #111111;
    overflow: hidden;
    height: 100%;
    font-family: 'Segoe UI', Tahoma, sans-serif;
    user-select: none;
  }
  canvas {
    display: block;
    position: absolute;
    top: 0;
    left: 0;
  }
  .node {
    position: absolute;
    background: #222;
    border: 1px solid #00ffff;
    border-radius: 6px;
    padding: 10px;
    color: #00ffff;
    cursor: grab;
    user-select: none;
    width: 140px;
    text-align: center;
  }
  .node:active {
    cursor: grabbing;
  }
</style>
</head>
<body>
  <canvas id="graph"></canvas>

  <div id="nodes-container"></div>

  <script>
    const canvas = document.getElementById("graph");
    const ctx = canvas.getContext("2d");
    let width = canvas.width = window.innerWidth;
    let height = canvas.height = window.innerHeight;

    // Узлы для графа (точки с радиусом)
    const nodeCount = 170;
    let nodes = [];
    let connections = [];
    let hoveredNodeIndex = null;

    // Для кастомных html-нод
    const htmlNodes = [];

    // Функция создания случайных граф-точек
    function createNodes() {
      nodes = [];
      for (let i = 0; i < nodeCount; i++) {
        const dx = (Math.random() - 0.5) * 0.3;
        const dy = (Math.random() - 0.5) * 0.3;
        const radius = (i % 2 === 0) ? 2 + Math.random() * 2 : 3 + Math.random() * 3;
        nodes.push({
          x: Math.random() * width,
          y: Math.random() * height,
          dx,
          dy,
          initialDx: dx,
          initialDy: dy,
          radius,
          targetRadius: 0,
          hasConnection: false
        });
      }
    }

    // Создаем связи
    function createConnections() {
      connections = [];
      nodes.forEach(n => n.hasConnection = false);

      for (let i = 0; i < nodes.length; i++) {
        let closest = null;
        let closestDist = Infinity;
        for (let j = 0; j < nodes.length; j++) {
          if (i === j) continue;
          const dx = nodes[i].x - nodes[j].x;
          const dy = nodes[i].y - nodes[j].y;
          const dist = Math.sqrt(dx*dx + dy*dy);
          if (dist < 180) {
            connections.push([i, j]);
            nodes[i].hasConnection = true;
            nodes[j].hasConnection = true;
          }
          if (dist < closestDist) {
            closestDist = dist;
            closest = j;
          }
        }
        if (!nodes[i].hasConnection || closestDist > 250) {
          if (closest !== null) {
            connections.push([i, closest]);
            nodes[i].hasConnection = true;
            nodes[closest].hasConnection = true;
          }
        }
      }
    }

    // Проверка на близость курсора к линии (для удаления связей)
    function isNearLine(x1,y1,x2,y2,px,py,threshold=5) {
      const A = px - x1;
      const B = py - y1;
      const C = x2 - x1;
      const D = y2 - y1;

      const dot = A*C + B*D;
      const len_sq = C*C + D*D;
      let param = -1;
      if (len_sq !== 0) param = dot / len_sq;

      let xx, yy;

      if (param < 0) {
        xx = x1;
        yy = y1;
      } else if (param > 1) {
        xx = x2;
        yy = y2;
      } else {
        xx = x1 + param * C;
        yy = y1 + param * D;
      }

      const dx = px - xx;
      const dy = py - yy;
      return (dx*dx + dy*dy) <= threshold*threshold;
    }

    // Удаление связи по клику
    canvas.addEventListener('click', e => {
      const rect = canvas.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;
      let clickedIndex = -1;
      for (let i = 0; i < connections.length; i++) {
        const [aIdx,bIdx] = connections[i];
        const a = nodes[aIdx];
        const b = nodes[bIdx];
        if (isNearLine(a.x,a.y,b.x,b.y,mx,my)) {
          clickedIndex = i;
          break;
        }
      }
      if (clickedIndex !== -1) {
        connections.splice(clickedIndex,1);
      }
    });

    // Отрисовка линий и точек
    function draw() {
      ctx.clearRect(0,0,width,height);
      ctx.fillStyle = "#111111";
      ctx.fillRect(0,0,width,height);

      // Линии
      connections.forEach(([i,j]) => {
        const a = nodes[i];
        const b = nodes[j];
        ctx.beginPath();
        ctx.moveTo(a.x,a.y);
        ctx.lineTo(b.x,b.y);
        ctx.strokeStyle = "#888";
        ctx.lineWidth = 1;
        ctx.stroke();
      });

      // Точки
      nodes.forEach(n => {
        ctx.beginPath();
        ctx.arc(n.x,n.y,n.radius,0,Math.PI*2);
        ctx.fillStyle = "#ccc";
        ctx.fill();
      });

      requestAnimationFrame(draw);
    }

    // Обновление положения точек
    function updatePositions() {
      nodes.forEach(n => {
        n.x += n.dx;
        n.y += n.dy;

        // Границы
        if (n.x < 10) { n.x = 10; n.dx = Math.abs(n.dx); }
        if (n.x > width - 10) { n.x = width - 10; n.dx = -Math.abs(n.dx); }
        if (n.y < 10) { n.y = 10; n.dy = Math.abs(n.dy); }
        if (n.y > height - 10) { n.y = height - 10; n.dy = -Math.abs(n.dy); }
      });
      setTimeout(updatePositions, 20);
    }

    // --- HTML ноды с перетаскиванием ---
    const nodesContainer = document.getElementById('nodes-container');

    function createHtmlNode(id, label, x, y) {
      const el = document.createElement('div');
      el.className = 'node';
      el.textContent = label;
      el.style.left = x + 'px';
      el.style.top = y + 'px';
      el.dataset.id = id;
      nodesContainer.appendChild(el);

      // Перетаскивание
      let offsetX, offsetY;
      let dragging = false;

      el.addEventListener('mousedown', e => {
        dragging = true;
        offsetX = e.clientX - el.offsetLeft;
        offsetY = e.clientY - el.offsetTop;
        el.style.cursor = 'grabbing';
      });

      window.addEventListener('mouseup', e => {
        dragging = false;
        el.style.cursor = 'grab';
      });

      window.addEventListener('mousemove', e => {
        if (dragging) {
          el.style.left = (e.clientX - offsetX) + 'px';
          el.style.top = (e.clientY - offsetY) + 'px';
          // Можно сюда добавить связь с canvas, если нужно
        }
      });

      htmlNodes.push(el);
      return el;
    }

    // Создаем пару html-нод для примера
    createHtmlNode('nodeA', 'Node A', 100, 100);
    createHtmlNode('nodeB', 'Node B', 300, 200);

    // Запускаем граф
    createNodes();
    createConnections();
    draw();
    updatePositions();

    // При ресайзе
    window.addEventListener('resize', () => {
      width = canvas.width = window.innerWidth;
      height = canvas.height = window.innerHeight;
    });
  </script>
</body>
</html>
